import { supabase } from './supabase';
import * as FileSystem from 'expo-file-system/legacy';

const SUPABASE_URL = process.env.EXPO_PUBLIC_SUPABASE_URL || '';

/**
 * Upload a file to Supabase Storage using FileSystem.uploadAsync.
 * Streams the file directly â€” no base64 memory issues, works with all URI types.
 */
async function uploadToStorage(
  bucket: string,
  storagePath: string,
  fileUri: string,
  contentType: string
): Promise<string> {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error('Niet ingelogd');

  const uploadUrl = `${SUPABASE_URL}/storage/v1/object/${bucket}/${storagePath}`;

  const result = await FileSystem.uploadAsync(uploadUrl, fileUri, {
    httpMethod: 'POST',
    uploadType: FileSystem.FileSystemUploadType.BINARY_CONTENT,
    headers: {
      Authorization: `Bearer ${session.access_token}`,
      'Content-Type': contentType,
      'x-upsert': 'true',
    },
  });

  if (result.status < 200 || result.status >= 300) {
    let msg = `Upload mislukt (${result.status})`;
    try {
      const body = JSON.parse(result.body);
      msg = body.message || body.error || msg;
    } catch {}
    throw new Error(msg);
  }

  const { data: urlData } = supabase.storage.from(bucket).getPublicUrl(storagePath);
  return urlData.publicUrl;
}

// Types
export interface MessageRecord {
  id: string;
  senderId: string;
  receiverId: string;
  conversationId: string | null;
  content: string;
  messageType: 'text' | 'voice' | 'image' | 'video' | 'document';
  mediaUrl: string | null;
  mediaDuration: number | null;
  read: boolean;
  sentAt: string;
  readAt: string | null;
}

export interface ConversationRecord {
  id: string;
  coachId: string;
  clientId: string;
  lastMessageAt: string;
  lastMessageText: string | null;
  unreadCountCoach: number;
  unreadCountClient: number;
  createdAt: string;
  // Joined data
  coachName?: string;
  clientName?: string;
  coachEmail?: string;
  clientEmail?: string;
  coachAvatarUrl?: string | null;
  clientAvatarUrl?: string | null;
}

function transformMessage(raw: any): MessageRecord {
  return {
    id: raw.id,
    senderId: raw.sender_id,
    receiverId: raw.receiver_id,
    conversationId: raw.conversation_id,
    content: raw.content,
    messageType: raw.message_type || 'text',
    mediaUrl: raw.media_url,
    mediaDuration: raw.media_duration,
    read: raw.read,
    sentAt: raw.sent_at,
    readAt: raw.read_at,
  };
}

function transformConversation(raw: any): ConversationRecord {
  return {
    id: raw.id,
    coachId: raw.coach_id,
    clientId: raw.client_id,
    lastMessageAt: raw.last_message_at,
    lastMessageText: raw.last_message_text,
    unreadCountCoach: raw.unread_count_coach || 0,
    unreadCountClient: raw.unread_count_client || 0,
    createdAt: raw.created_at,
  };
}

/**
 * Get or create conversation with coach.
 * For clients: finds their conversation or creates one.
 */
export async function getOrCreateConversation(): Promise<ConversationRecord> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  // Try to find existing conversation as client
  const { data: existing } = await supabase
    .from('conversations')
    .select('*')
    .eq('client_id', user.id)
    .order('last_message_at', { ascending: false })
    .limit(1)
    .maybeSingle();

  if (existing) {
    const conv = transformConversation(existing);
    return enrichWithCoachProfile(conv);
  }

  // Find the user's coach from active coaching relationship
  const { data: relationship } = await supabase
    .from('coaching_relationships')
    .select('coach_id')
    .eq('client_id', user.id)
    .eq('status', 'ACTIVE')
    .limit(1)
    .maybeSingle();

  const coachId = relationship?.coach_id;
  if (!coachId) throw new Error('No coach assigned');

  // Create new conversation (id generated by database default gen_random_uuid())
  const { data: newConv, error } = await supabase
    .from('conversations')
    .insert({
      coach_id: coachId,
      client_id: user.id,
    })
    .select()
    .single();

  if (error) throw error;
  const conv = transformConversation(newConv);
  return enrichWithCoachProfile(conv);
}

/**
 * Enrich conversation with coach profile (name + avatar).
 */
async function enrichWithCoachProfile(conv: ConversationRecord): Promise<ConversationRecord> {
  const { data: profile } = await supabase
    .from('profiles')
    .select('first_name, last_name, avatar_url')
    .eq('user_id', conv.coachId)
    .maybeSingle();

  if (profile) {
    conv.coachName = `${profile.first_name || ''} ${profile.last_name || ''}`.trim() || 'Coach';
    conv.coachAvatarUrl = profile.avatar_url;
  }
  return conv;
}

/**
 * Get all conversations for the current user (coach or client).
 */
export async function fetchConversations(): Promise<ConversationRecord[]> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  const { data, error } = await supabase
    .from('conversations')
    .select('*')
    .or(`coach_id.eq.${user.id},client_id.eq.${user.id}`)
    .order('last_message_at', { ascending: false });

  if (error) throw error;
  return (data || []).map(transformConversation);
}

/**
 * Fetch messages for a conversation.
 */
export async function fetchMessages(
  conversationId: string,
  limit: number = 50
): Promise<MessageRecord[]> {
  const { data, error } = await supabase
    .from('messages')
    .select('*')
    .eq('conversation_id', conversationId)
    .order('sent_at', { ascending: false })
    .limit(limit);

  if (error) throw error;
  return (data || []).map(transformMessage).reverse();
}

/**
 * Send a text message.
 */
export async function sendTextMessage(
  conversationId: string,
  receiverId: string,
  content: string
): Promise<MessageRecord> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  const { data, error } = await supabase
    .from('messages')
    .insert({
      sender_id: user.id,
      receiver_id: receiverId,
      conversation_id: conversationId,
      content,
      message_type: 'text',
    })
    .select()
    .single();

  if (error) throw error;

  // Update conversation
  await supabase
    .from('conversations')
    .update({
      last_message_at: new Date().toISOString(),
      last_message_text: content.substring(0, 100),
    })
    .eq('id', conversationId);

  return transformMessage(data);
}

/**
 * Send a voice note message.
 */
export async function sendVoiceMessage(
  conversationId: string,
  receiverId: string,
  audioUri: string,
  durationSeconds: number
): Promise<MessageRecord> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  const storagePath = `${user.id}/${Date.now()}.m4a`;
  const publicUrl = await uploadToStorage('voice-notes', storagePath, audioUri, 'audio/m4a');

  const { data, error } = await supabase
    .from('messages')
    .insert({
      sender_id: user.id,
      receiver_id: receiverId,
      conversation_id: conversationId,
      content: 'ðŸŽ¤ Spraakbericht',
      message_type: 'voice',
      media_url: publicUrl,
      media_duration: durationSeconds,
    })
    .select()
    .single();

  if (error) throw error;

  await supabase
    .from('conversations')
    .update({
      last_message_at: new Date().toISOString(),
      last_message_text: 'ðŸŽ¤ Spraakbericht',
    })
    .eq('id', conversationId);

  return transformMessage(data);
}

/**
 * Send an image/video/document message.
 */
export async function sendMediaMessage(
  conversationId: string,
  receiverId: string,
  fileUri: string,
  messageType: 'image' | 'video' | 'document',
  fileName?: string
): Promise<MessageRecord> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  // Determine content type and extension
  const ext = fileUri.split('.').pop()?.toLowerCase() || 'bin';
  const contentTypeMap: Record<string, string> = {
    jpg: 'image/jpeg', jpeg: 'image/jpeg', png: 'image/png', gif: 'image/gif', webp: 'image/webp', heic: 'image/heic',
    mp4: 'video/mp4', mov: 'video/quicktime', avi: 'video/x-msvideo',
    pdf: 'application/pdf', doc: 'application/msword',
    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    xls: 'application/vnd.ms-excel',
    xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  };
  const contentType = contentTypeMap[ext] || 'application/octet-stream';

  const storagePath = `${user.id}/${Date.now()}.${ext}`;
  const publicUrl = await uploadToStorage('chat-media', storagePath, fileUri, contentType);

  const previewText = messageType === 'image' ? 'ðŸ“· Foto'
    : messageType === 'video' ? 'ðŸŽ¬ Video'
    : `ðŸ“Ž ${fileName || 'Document'}`;

  const { data, error } = await supabase
    .from('messages')
    .insert({
      sender_id: user.id,
      receiver_id: receiverId,
      conversation_id: conversationId,
      content: previewText,
      message_type: messageType,
      media_url: publicUrl,
    })
    .select()
    .single();

  if (error) throw error;

  await supabase
    .from('conversations')
    .update({
      last_message_at: new Date().toISOString(),
      last_message_text: previewText,
    })
    .eq('id', conversationId);

  return transformMessage(data);
}

/**
 * Mark messages as read.
 */
export async function markMessagesAsRead(conversationId: string): Promise<void> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  await supabase
    .from('messages')
    .update({ read: true, read_at: new Date().toISOString() })
    .eq('conversation_id', conversationId)
    .eq('receiver_id', user.id)
    .eq('read', false);
}

/**
 * Get unread message count for the current user.
 */
export async function getUnreadCount(): Promise<number> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return 0;

  const { count, error } = await supabase
    .from('messages')
    .select('*', { count: 'exact', head: true })
    .eq('receiver_id', user.id)
    .eq('read', false);

  if (error) return 0;
  return count || 0;
}
